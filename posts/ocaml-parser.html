<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-03-09">

<title>Timothy Wolodzko - Writing parser in ocamllex and menhir</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V9DH8RH1V5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V9DH8RH1V5', { 'anonymize_ip': true});
</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Timothy Wolodzko</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Writing parser in ocamllex and menhir</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">blog</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 9, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><a href="https://ocaml.org/">OCaml</a> is a great language for creating programming languages. In fact, it is inspired by the <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML language</a> (hence “ml” in its name), which as discussed by its author Robin Milner in <em><a href="https://smlfamily.github.io/sml97-defn.pdf">The Definition of Standard ML</a></em> book,</p>
<blockquote class="blockquote">
<p>‘ML’ stands for meta language; this is the term logicians use for a language in which other (formal or informal) languages are discussed and analyzed.</p>
</blockquote>
<p>Besides being very flexible, having a nice typing system, and powerful <a href="https://sodocumentation.net/ocaml/topic/2656/pattern-matching">pattern matching</a>, all are helpful, it also has great libraries including <a href="https://v2.ocaml.org/manual/lexyacc.html#sec278"><code>ocamllex</code></a> or <a href="https://github.com/ocaml-community/sedlex"><code>sedlex</code></a> (better support for unicode) for building <a href="https://en.wikipedia.org/wiki/Lexical_analysis">lexers</a>, and <a href="https://v2.ocaml.org/manual/lexyacc.html#sec278"><code>ocamlyacc</code></a> and its more modern cousin <a href="http://cambium.inria.fr/~fpottier/menhir/"><code>menhir</code></a> for building parsers. There are many <a href="https://cs3110.github.io/textbook/chapters/interp/parsing.html">tutorials</a> on using them, showing how to build a parser for a <a href="https://mukulrathi.com/create-your-own-programming-language/parsing-ocamllex-menhir/">calculator</a>, or <a href="https://www.aleksandra.codes/parsing-json-with-ocaml/">JSON</a>, which is also discussed in the great <em><a href="https://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html">Real World OCaml</a></em> book.</p>
<p>Below I’ll be intentionally omitting some implementation details and boilerplate, so for the full code remember to check the <a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/">actual implementation</a> or an <a href="https://github.com/twolodzko/lambda">interpreter</a>.</p>
<section id="lambda-calculus" class="level2">
<h2 class="anchored" data-anchor-id="lambda-calculus">Lambda calculus</h2>
<p><a href="https://theory.stanford.edu/~blynn/lambda/">Lambda calculus</a> can be seen as the simplest programming language, it has <a href="https://en.wikipedia.org/wiki/Lambda_calculus">three kinds</a> of <em>terms</em>,</p>
<ul>
<li>a <em>variable</em>, e.g.&nbsp;<span class="math inline">\(x\)</span>,</li>
<li>an <em>application</em> like <span class="math inline">\(t ~ u\)</span>, where <span class="math inline">\(t\)</span> is the function applied to the <span class="math inline">\(u\)</span> argument,</li>
<li>and an <em>abstraction</em> <span class="math inline">\(\lambda x . t\)</span>, which is a function with an argument <span class="math inline">\(a\)</span> and the body <span class="math inline">\(t\)</span>.</li>
</ul>
<p>This can be translated to the following OCaml data type</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/term.ml"><code>term.ml</code></a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> term =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | Abs <span class="kw">of</span> <span class="dt">string</span> * term</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I’ll use it as an example for writing a parser.</p>
</section>
<section id="tokens" class="level2">
<h2 class="anchored" data-anchor-id="tokens">Tokens</h2>
<p>Having defined the types, we can start building a parser that would convert the source code representation of lambda calculus expressions to an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>. Let’s start with the tokens that we will be extracting from the source code.</p>
<p>A variable is a string identifying its name, that would make a <code>&lt;string&gt; ID</code> token. An abstraction starts with the Greek letter <span class="math inline">\(\lambda\)</span> that we’ll represent with the <code>LAMBDA</code> token. It also uses <span class="math inline">\(.\)</span> <code>DOT</code> to separate the function argument from the body. But that is not all, as we can also group things by placing them between the left <code>LPAREN</code> and right <code>RPAREN</code> bracket. Unlike many programming languages that mark the end of the expression with things like <code>;</code>, nothing like this exists in lambda calculus, so we would assume that the end of the line <code>END</code> marks also the end of the expression. We would also use <code>EOF</code> for the end of the file so that we know that there’s nothing more to parse.</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/parser.mly"><code>parser.mly</code></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>%token &lt;<span class="dt">string</span>&gt; ID</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>%token LPAREN <span class="st">"("</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>%token RPAREN <span class="st">")"</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>%token LAMBDA <span class="st">"λ"</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>%token DOT <span class="st">"."</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>%token END</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>%token EOF</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The quoted symbols on the right-hand side are just aliases, so we could write <code>"λ"</code> instead of <code>LAMBDA</code> to make the parser code more readable.</p>
</section>
<section id="lexer" class="level2">
<h2 class="anchored" data-anchor-id="lexer">Lexer</h2>
<p><a href="https://en.wikipedia.org/wiki/Lexical_analysis">Lexer</a> reads source code character by character transforming it into tokens.</p>
<p>A mathematician might be fine with writing <span class="math inline">\(fxy\)</span> meaning applying function <span class="math inline">\(f\)</span> with arguments <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, but the rest of us would probably appreciate being able to write meaningful multi-character names like <code>myfunc foo bar</code>. To do this, we would need to be able to mark where the names start and end, and the simplest way is to use whitespaces for that, so we need to define the <code>white</code> characters. Since we don’t care if we saw single or multiple whitespaces in the row, we would use <code>+</code> in the <a href="https://v2.ocaml.org/releases/4.11/htmlman/lexyacc.html">regular expression</a> to say “one or more”.</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/lexer.mll"><code>lexer.mll</code></a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> white = [<span class="ch">' '</span> <span class="ch">'\t'</span>]+</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For marking the end of an expression, we’ll use <code>newline</code> characters.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> newline = <span class="ch">'\r'</span> | <span class="ch">'\n'</span> | <span class="st">"</span><span class="ch">\r\n</span><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are some reserved characters like <code>(</code>, <code>)</code>, <code>.</code>, <code>λ</code>, etc but all the others could be considered as identifiers, so we would define a set of reserved characters and negate it with <code>^</code> in the regular expression.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">string</span> = [^ <span class="ch">'('</span> <span class="ch">')'</span> <span class="ch">'\\'</span> <span class="ch">'.'</span> <span class="ch">'#'</span> <span class="ch">' '</span> <span class="ch">'\t'</span> <span class="ch">'\n'</span> <span class="ch">'\t'</span>]+</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can start defining the lexing rules. The simplest case is reaching the end of the file, or a newline character, so we return the <code>EOF</code> or <code>END</code> token.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>rule read =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  parse</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    | eof { EOF }</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    | newline { END }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For whitespaces, the lexing rule is to read the next character by recursively calling the <code>read</code> rule.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    | white { read lexbuf }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the brackets, we would be returning the appropriate tokens.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    | <span class="st">"("</span> { LPAREN }</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    | <span class="st">")"</span> { RPAREN }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The same happens for <span class="math inline">\(\lambda\)</span>, but since it is not straightforward to write Greek letters using most keyboards, we would use <code>\</code> as an alternative (as in <a href="https://wiki.haskell.org/Lambda_abstraction">Haskell</a>).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    | <span class="st">"</span><span class="ch">\\</span><span class="st">"</span> { LAMBDA }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    | <span class="st">"λ"</span> { LAMBDA }</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    | <span class="st">"."</span> { DOT }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the identifiers, i.e.&nbsp;all the other strings, we would return the <code>ID</code> token with the string as its value.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">string</span> { ID (lexeme lexbuf) }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, it would be useful to support code comments. <code>#</code> would mark the start of the comment that continues till the end of the line. In such a case, the lexer would call the <code>skip_line</code>. The rule would recursively call itself while skipping the characters until hitting the <code>newline</code> character, which would bring us back to the <code>read</code> rule again.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    | <span class="st">"#"</span> { skip_line lexbuf }</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">and</span> skip_line =</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  parse</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    | newline { new_line lexbuf; read lexbuf }</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    | eof { EOF }</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    | _ { skip_line lexbuf }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="parser" class="level2">
<h2 class="anchored" data-anchor-id="parser">Parser</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Parsing#Parser">parser</a> converts the stream of tokens to an abstract syntax tree representation of the code.</p>
<p>We would start with the simplest case of parsing the variables. When reaching the <code>ID</code> token, the parser would transform its <code>x</code> value to <code>Var</code> with the identifier <code>x</code>.</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/parser.mly"><code>parser.mly</code></a></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> variable :=</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  | x = ID; { Var x }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Parsing the applications is slightly harder. As a reminder, applications can take <span class="math inline">\(x ~ y\)</span> form, where both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be <em>any</em> terms (let’s assume for now that <code>term</code> is already defined). We could naively define it as one term following another.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  | t = term; u = term; { App (t, u) }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But in such a case, the compiler would show us warnings that the rule is ambiguous.</p>
<pre><code>Warning: 2 states have shift/reduce conflicts.
Warning: 6 shift/reduce conflicts were arbitrarily resolved.</code></pre>
<p>The application could be <span class="math inline">\(t ~ u\)</span>, but also <span class="math inline">\(a ~ b ~ c\)</span>, or <span class="math inline">\(a ~ b ~ \lambda x . x\)</span>. Since <code>App</code> has only two fields, how would we parse such cases? By convention, the application is associative to the left, so <span class="math inline">\(a ~ b ~ c ~ d\)</span> reads as <span class="math inline">\(((a ~ b) c) d\)</span>. Moreover, in the case where we would like to change the application order, we can use the brackets, e.g.&nbsp;<span class="math inline">\(f x (y z)\)</span> would become <span class="math inline">\((f x) (y z)\)</span>. To parse it, we will first define the <code>element</code> that can be a result of the <code>variable</code> rule, that we already defined, or a <code>term</code> (wait for it…) surrounded by brackets.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> element :=</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  | variable</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  | <span class="st">"("</span>; x = term; <span class="st">")"</span>; { x }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can create a recursive <code>application</code> rule. Starting from the second part of the rule, if there is an <code>application</code> <code>t</code> and an <code>element</code> <code>u</code> following it, it reads it as a new application <code>App (App (_, _), u)</code>. The first part of the rule is that we just read an <code>element</code>. By definition of the <code>element</code>, it can be something surrounded by brackets, or a single variable.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> application :=</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  | element</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  | t = application; u = element; { App (t, u) }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a side note, this makes the definition of <code>application</code> slightly misleading, since it will read also things like the variable <span class="math inline">\(x\)</span>, or <span class="math inline">\((\lambda x . x)\)</span> (using the <code>element</code> part of the rule), but we’ll sacrifice a bit of purity to make it work.</p>
<p>Now we need to define the parsing rule for abstractions. As a reminder, an abstraction takes the <span class="math inline">\(\lambda x . t\)</span> form, identity function <span class="math inline">\(\lambda x . x\)</span> is the simplest example. But, what I didn’t mention yet, it can have multiple arguments, e.g.&nbsp;<span class="math inline">\(\lambda x y . x y\)</span> reads as <span class="math inline">\(\lambda x . \lambda y . x y\)</span>. Abstractions follow a different convention than applications, they extend to the right, so <span class="math inline">\(\lambda x . x y z\)</span> is <span class="math inline">\(\lambda x . (x y z)\)</span> <em>not</em> <span class="math inline">\((\lambda x . x) y z\)</span>. This is related to <a href="https://en.wikipedia.org/wiki/Currying">currying</a>, but it’s a different story.</p>
<p>The parsing rule for an <code>abstraction</code> is that it is something starting with the <code>"λ"</code> token that is followed by an argument, and then the rest of it follows. In the simplest case, after the argument, there is a <code>"."</code> token and the body of a function. Alternatively, it may be followed by another argument and something following it, using the above rule recursively. This translates to the two rules: <code>abstraction</code> which reads the head of the function and <code>body</code> which reads its tail.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> abstraction :=</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  | <span class="st">"λ"</span>; x = ID; u = body; { Abs (x, u) }</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> body :=</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  | <span class="st">"."</span>; u = term; { u }</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  | x = ID; u = body; { Abs (x, u) }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Having all the rules for reading the individual terms, we can finally define the <code>term</code> that reads an <code>application</code> (which can read a single <code>variable</code> or an application consisting of more elements) or an <code>abstraction</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> term :=</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  | application</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  | abstraction</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we want to have a general rule for reading the <code>term</code>s. It will terminate the parser on <code>EOF</code>, read the <code>term</code>s followed by the newline <code>END</code> tokens, and proceed to read the next token following the <code>END</code> (the middle rule).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> prog :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  | EOF; { <span class="dt">None</span> }</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  | END; p = prog; { p }</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  | t = term; line_end; { <span class="dt">Some</span> t }</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> line_end := END | EOF</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="wrap-it-up" class="level2">
<h2 class="anchored" data-anchor-id="wrap-it-up">Wrap it up</h2>
<p>Having finished the above, we need to inform the OCaml parser to call <code>ocamllex</code> and <code>menhir</code> so that they create the lexer and parser for us. This is specified in the <code>dune</code> file that uses lisp syntax for the compiler configuration. The definition assumes that we have a lexer defined in the <code>lexer.mll</code> file and a parser in the <code>parser.mly</code> file.</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/dune"><code>dune</code></a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lisp code-with-copy"><code class="sourceCode commonlisp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(ocamllex lexer)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>(menhir</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a> (modules parser))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Calling <code>dune build</code> would now create the lexer and parser modules for us. To check how they work, we can create an executable command-line program that reads user input from standard input and prints the parsed representation. For this, we would use the recursive <code>loop</code> function that calls the <code>prog</code> function from our parser, which uses the <code>read</code> function from the lexer.</p>
<p><a href="https://github.com/twolodzko/twolodzko.github.io/blob/main/snippets/ocaml-parser/main.ml"><code>main.ml</code></a></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ocaml code-with-copy"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> loop lexer =</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">flush</span> <span class="dt">stdout</span>;</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> _ = <span class="kw">match</span> Parser.prog Lexer.read lexer <span class="kw">with</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> t -&gt;</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">"%s</span><span class="ch">\n\n</span><span class="st">"</span> (show_term t);</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; () <span class="kw">in</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  loop lexer</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  loop (from_channel <span class="dt">stdin</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>OCaml has great tools for building parsers. It allows us to write lexers using rules based on regular expressions, that could be made even more flexible by calling other rules (basically, functions). For building parsers, we can also use rich functional, pattern-matching-based language to build declarative parsing rules that would be translated into a parser for us by <code>menhir</code> or <code>ocamlyacc</code>. If you know OCaml, they are really easy to learn and quite intuitive.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>