<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-11-29">

<title>Timothy Wolodzko - Lessons learned from implementing minimal Scheme four six times</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V9DH8RH1V5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V9DH8RH1V5', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Timothy Wolodzko</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Lessons learned from implementing minimal Scheme <del>four</del> six times</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">blog</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 29, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>We were in the middle of a global pandemic. Tormented by fear, locked in our homes, everyone was coping in their own way. Some people started baking bread, writing poetry, learning to play guitar, or doing home gardening, and I… went re-implementing Scheme lisps. Creating minimal Scheme interpreters became my favorite programming kata. By “minimal” I mean bare-bones language but feature-rich enough that can run all the examples from the classic <em><a href="https://www.goodreads.com/book/show/548914.The_Little_Schemer">The Little Schemer</a></em> book by Daniel P. Friedman and Matthias Felleisen.</p>
<blockquote class="blockquote">
<p><em>Do It, Do It Again, and Again, and Again …</em><br>
  — <em>The Little Schemer</em> by Friedmann and Felleisen</p>
</blockquote>
<p>I implemented it already in <a href="https://github.com/twolodzko/gosch">Go</a>, <a href="https://github.com/twolodzko/loco">OCaml</a>, <a href="https://github.com/twolodzko/schemero">Erlang</a>, and <a href="https://github.com/twolodzko/schsch">Racket</a> (itself a flavor of Scheme). My main purpose was to learn new programming languages and learn more about programming language theory (in practice). To verify my code, as an integration test, I used the examples from <em><a href="https://www.goodreads.com/book/show/548914.The_Little_Schemer">The Little Schemer</a></em> and accompanying unit tests from the <a href="https://github.com/bmitc/the-little-schemer">repository by <em>bmitc</em></a>. I was also benchmarking my code against MIT Scheme.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://imgs.xkcd.com/comics/lisp_cycles.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Lisp cycles XKCD #297: “Those are your father’s parentheses. Elegant weapons for a more… civilized age.”</figcaption>
</figure>
</div>
<p>(source <a href="https://xkcd.com/297/" class="uri">https://xkcd.com/297/</a>)</p>
<section id="why-implementing-a-lisp-is-such-a-great-kata" class="level1">
<h1>Why implementing a lisp is such a great kata?</h1>
<p>Implementing lisp interpreters is my favorite programming kata. It is a non-trivial problem, but small enough to finish it in a limited time. It is also a chance to touch most of the functionalities of the programming language you use for the problem:</p>
<ul>
<li><p>You need to build a simple parser. This is an interesting programming exercise by itself. It also lets you familiarize yourself with strings.</p></li>
<li><p>Lisp uses <a href="https://en.wikipedia.org/wiki/Cons">cons linked lists</a> for all purposes. Some languages support linked lists natively (OCaml, Racket), some don’t, and in some, it is particularly hard (<a href="https://rust-unofficial.github.io/too-many-lists/">Rust</a>). This is how you’ll score a point in a leetcode-style whiteboard interview when they’ll ask to implement a linked list.</p></li>
<li><p>It is a chance to learn about types in the programming language you use. Some languages have advanced type systems (e.g.&nbsp;OCaml, Rust), but some don’t support custom types (e.g.&nbsp;erlang, Lua), so you need to simulate them.</p></li>
<li><p>To store the variables, you need an environment. There is a global environment, but also local ones (see <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> and <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">scopes</a>). For this, you’d likely need tree-like data structures, references, and hash maps.</p></li>
<li><p>For <a href="https://en.wikipedia.org/wiki/Anonymous_function">lambdas</a>, you’ll need to learn more about anonymous functions.</p></li>
<li><p>Lisps extensively use recursion, so the implementation needs to be <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail-call optimized</a>, otherwise you’ll quickly see <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow errors</a>. The best way to unit-test it is to use a tail-call optimized implementation of Fibonacci sequence generator and evaluate it for a large value of the argument (&gt;100).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme code-with-copy"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> impl </span>(<span class="kw">lambda</span> (it second first)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">if</span> (<span class="op">=</span> it <span class="dv">0</span>) first</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (impl (<span class="op">-</span> it <span class="dv">1</span>) (<span class="op">+</span> first second) second))))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> fibo </span>(<span class="kw">lambda</span> (n) (impl n <span class="dv">1</span> <span class="dv">0</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>To build REPL, you’ll need to learn how to interact with standard input and output.</p></li>
<li><p>When using REPL, it doesn’t panic on each error, but rather prints the error message. If you want this behavior, you need to explore how errors are handled in the programming language you use.</p></li>
<li><p>Finally, you would learn to build a command-line interface.</p></li>
</ul>
</section>
<section id="prologue" class="level1">
<h1>Prologue</h1>
<p>I don’t have a computer science background, and one day I decided to learn more about programming language theory. I started reading <a href="https://www.goodreads.com/book/show/703102.Compilers">the dragon book</a>, though I never finished it. I needed something more practical and hands-on, and this is how I discovered the <em><a href="https://www.goodreads.com/book/show/21857827-build-your-own-lisp">Build Your Own Lisp</a></em> book. It was nice, but it had code examples in C and focused too much on C for me. Hopefully, I also found the great <em><a href="https://www.goodreads.com/book/show/32681092-writing-an-interpreter-in-go">Writing An Interpreter In Go</a></em> book that used Go language to illustrate building an interpreter for a (non-lisp) programming language. Another great inspiration and source of help were the <a href="https://github.com/kanaka/mal">make a lisp repository</a> with an end-to-end tutorial and learning materials for freaks like me. Around the same time, I was reading the classic programming books: <em><a href="https://www.goodreads.com/book/show/548914.The_Little_Schemer">The Little Schemer</a></em> and <em><a href="https://www.goodreads.com/book/show/43713.Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a></em>, which used Scheme, so I was curious to write my Scheme, to get a better “behind the scenes” understanding. Among other resources, <em><a href="https://www.scheme.com/tspl4/">The Scheme Programming Language</a></em> reference book by R. Kent Dybvig was helpful as well.</p>
</section>
<section id="go" class="level1">
<h1>Go</h1>
<p>I was curious about Go. The <em><a href="https://www.goodreads.com/book/show/32681092-writing-an-interpreter-in-go">Writing An Interpreter In Go</a></em> book motivated me, even more, to try implementing a lisp in this language. Go was very easy to learn, pleasant to work with, and has great documentation. To familiarize myself better with the language, I’ve read the <em><a href="https://www.goodreads.com/book/show/55841848-learning-go">Learning Go</a></em> book, which I can recommend. Implementing a Scheme interpreter in Go was not straightforward, because the two languages are <em>very</em> different. Listing all the differences would be pointless, but the biggest one was that Go is statically typed, while Scheme is dynamically typed. To implement dynamic typing in Go, one needs to use <a href="https://golangdocs.com/interfaces-in-golang"><code>interface{}</code></a> type and cast it to desired types each time it’s needed. It resulted in a lot of boilerplate code. Scheme’s lists are just <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a>, that differ significantly from Go’s native arrays and <a href="https://go.dev/blog/slices-intro">slices</a>, so I implemented it as a custom linked list myself. I described the design in greater detail in <a href="https://github.com/twolodzko/gosch">the readme</a> of my repository. It was a great learning experience. I not only learned a lot about Scheme, but also the consequences of static vs dynamic typing, passing by values vs references, linked lists, and many other things.</p>
</section>
<section id="ocaml" class="level1">
<h1>OCaml</h1>
<p>I knew the basics of OCaml before deciding to write my second implementation of Scheme in it. The two books that were a great introduction for me: <em><a href="https://www.goodreads.com/book/show/18212242-ocaml-from-the-very-beginning">OCaml from the Very Beginning</a></em> and <em><a href="https://dev.realworldocaml.org/">Real World OCaml</a></em> (freely available online). While working on it, I found <a href="https://bernsteinbear.com/blog/lisp/00_fundamentals/">this blog</a> where the author also implemented a lisp in OCaml. Same as Scheme, OCaml uses lists as a basic data structure and recursion as the default working mode, which made implementing it fairly straightforward. Moreover, OCaml has great pattern-matching utilities that made code much simpler and more compact than the Go implementation (~500 lines vs ~2000 lines). OCaml’s strong, but much more flexible than Go’s (which was bothersome), typing was also of great help to prevent type inconsistencies and warn me about potential problems early on. From the downsides, I didn’t find OCaml documentation that fabulous and I struggled a bit to understand how should I structure my project, handle dependencies, properly run unit tests, etc. The biggest surprise was that my implementation in OCaml was approximately five times faster than the one in Go (aka “the fast language”)!</p>
</section>
<section id="erlang" class="level1">
<h1>Erlang</h1>
<p>OK, that was a crazy one. I heard about Erlang and how it is an outlier in programming languages and wanted to learn it for some time. Implementing Scheme in it seemed to be right in the sweet spot: not trivial, complex enough, but doable in a finite amount of time. It also touched on many features of the language. I wasn’t aiming for performance (Erlang is slow), or doing it most efficiently, but rather playing around with Erlang’s features. Since Erlang was a bit scary to start with, I first read about Elixir (a language like Erlang, but with modern, Ruby-like syntax) from the <em><a href="https://www.goodreads.com/book/show/17971957-programming-elixir">Programming Elixir</a></em> book and did the <a href="https://exercism.org/tracks/elixir">Exercism learning track</a> (a good one). However, I wanted to go all the way down the rabbit hole (also “schemero” seemed to be a cool name, tbh). I started by reading Erlang’s author book <em><a href="https://www.goodreads.com/book/show/808814.Programming_Erlang">Programming Erlang</a></em>, and found <em><a href="https://learnyousomeerlang.com/contents">Learn You Some Erlang for Great Good!</a></em> (available freely online) very helpful. Like Scheme and OCaml, Erlang mostly works with lists and recursion. Same as OCaml, it has great pattern-matching utilities. But it has its quirks: its dynamically typed and does not support custom types (you can imitate them by using structs, e.g.&nbsp;<code>{symbol, "name"}</code> for a symbol type), moreover <em>every</em> object in Erlang is immutable (what has many interesting consequences), it has a strange (but likable!) syntax and stylistic conventions. The strangest of all is how Erlang treats everything as <a href="https://www.erlang.org/blog/message-passing/">message passing</a>. Since I wanted to learn more about it, my parser is a server that communicates with another server (that reads from a file or stdin) and returns parsed objects when available (e.g.&nbsp;user types something in REPL). Also, I treated environments as servers, so that they can hold all the Scheme objects and allow for mutating them (in Erlang you do mutability by playing <a href="https://en.wikipedia.org/wiki/Hot_potato">hot potato</a> and <a href="https://learnyousomeerlang.com/more-on-multiprocessing#state-your-state">passing the state</a> between the functions). The final implementation lacked garbage collector, and was not efficient, but worked and passed all the tests. And, oh boy, what a ride it was.</p>
</section>
<section id="racket" class="level1">
<h1>Racket</h1>
<p>You may ask: <em>why would anyone implement Scheme in Scheme?!</em> In the end, the only thing you need to do is to run something like <code>(eval (read ...))</code>. Yes, but that would be too easy. I wanted to have a parser that reads textual input and parses it to Scheme-like objects, I wanted to imitate the types, environments, closures, etc. I found <a href="https://docs.racket-lang.org/index.html">Racket’s documentation</a> very helpful (though not perfect). Having already read a lot about Scheme and implemented it thrice, doing it in Racket was fairly easy. It was a chance to appreciate Scheme’s more advanced features like macros and classes (yes, it has classes, but check <em><a href="https://www.goodreads.com/book/show/43713.Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a></em> to learn how they are just syntactic sugar) to imitate the stateful environments. The biggest pain was when I decided to build REPL and needed to find out how should I properly read the input from stdin and stream it to the parser. For building the command line interface, beyond the official docs I found only <a href="https://jackwarren.info/posts/guides/racket/racket-command-line/">one brief blog post</a> on how to do it, so I just went by trial and error to figure out how to do it. The hardest part was the “simple” things.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://imgs.xkcd.com/comics/tasks.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Tasks XKCD #1425: - “When a user takes a photo the app should check whether they’re in a national park…” - “Sure, easy GIS lookup. Gimme a few hours.” - “… and check whether the photo is of a bird.” - “I’ll need a research team and five years.” Comment: In CS, it can be hard to explain the difference between the easy and the virtually impossible.</figcaption>
</figure>
</div>
<p>(source <a href="https://xkcd.com/1425/" class="uri">https://xkcd.com/1425/</a>)</p>
</section>
<section id="so-what-are-the-pros-and-cons-of-those-languages" class="level1">
<h1>So what are the pros and cons of those languages?</h1>
<ul>
<li><strong>Go</strong> is elegant in its simplicity and has great documentation and developer tools. It has a simple but strict static type system, so implementing dynamic types was quite tedious. The big upside is that Go has a large and active community, so it’s easy to find online an answer to any <em>“how to…”</em> question, or get it answered on <a href="http://www.stackoverflow.com">StackOverflow.com</a> (not necessarily the case for the other languages).</li>
<li><strong>OCaml</strong> was a real pleasure to use, though it would be even better if it had better documentation.</li>
<li><strong>Erlang</strong>… is interesting. There are many great ideas behind it. It also shows how the simplicity of a language does not make it less expressive: all the values are immutable, it has <a href="https://stackoverflow.com/questions/4476108/namespaces-and-records-in-erlang">no namespaces</a>, no custom types, etc, while being a language designed for building complex, concurrent systems. I liked how Erland uses uppercase-only for variable names, making them visually distinct (Go does a similar thing for private vs public functions).</li>
<li><strong>Scheme</strong>, oh good old Scheme. What I was missing the most as compared to other functional languages was pattern-matching. Being able to write <code>[Head | Tail] = List</code> (Erlang) instead of <code>(let ([head (car lst)] [tail (cdr lst)]) ...)</code> is so much cleaner. A lisp with pattern-matching wouldn’t differ that much from any modern functional language. The documentation could be improved.</li>
</ul>
</section>
<section id="whats-next" class="level1">
<h1>What’s next?</h1>
<p>It was a great learning experience. Now, I’m struggling between resting from lisp and the compulsion to repeat it in another language. It could be a chance to learn better how Haskell handles side effects. On another hand, I already did it in functional languages. Cool kids those days learn Rust<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, so who knows? Lua also sounds intriguing.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Finally, I didn’t touch JavaScript for years and there is this TypeScript thing, right? Or maybe Crystal? Some masochistic part of me thinks of doing it in AWK or a <a href="https://twolodzko.github.io/makefile-programming">Makefile</a>, but not sure if this would be the pleasant kind of pain.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>I did it: <a href="https://github.com/twolodzko/rusch" class="uri">https://github.com/twolodzko/rusch</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I also did it: <a href="https://github.com/twolodzko/luali" class="uri">https://github.com/twolodzko/luali</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>