<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-01-21">

<title>Timothy Wolodzko - Learning Rust by implementing the lisp interpreter</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V9DH8RH1V5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V9DH8RH1V5', { 'anonymize_ip': true});
</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Timothy Wolodzko</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Learning Rust by implementing the lisp interpreter</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">blog</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 21, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Rust is not the greatest language for implementing lisp interpreter. First, lisp uses the <a href="https://en.wikipedia.org/wiki/Cons">cons linked lists</a> for everything, while implementing them is <a href="https://rust-unofficial.github.io/too-many-lists/index.html">notoriously hard</a> in Rust. Second, Rust <a href="https://stackoverflow.com/questions/32677420/what-does-rust-have-instead-of-a-garbage-collector">does not have a garbage collector</a>, while lisp does, so we need to implement some kind of memory management mechanism by ourselves. On the good side, Rust’s pattern matching and strong type system are quite helpful for the problem.</p>
<p>When I started I didn’t have <em>any</em> experience with Rust. I’ve read the <em><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming Rust: Fast, Safe Systems Development</a></em> book by Jim Blandy, Jason Orendorff, and Leonora F . S. Tindall and it was quite helpful. I’ve also skimmed through <em><a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></em> by Steve Klabnik and Carol Nichols and used it as a reference. I also found the <a href="https://doc.rust-lang.org/std/index.html">official documentation</a> very useful.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/dads-learning-to-program.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">“Dad, no! Mom! Dad’s learning to program again!” https://laserdisc.party/<span class="citation" data-cites="andy/109712218341157640">@andy/109712218341157640</span></figcaption><p></p>
</figure>
</div>
<section id="first-step-the-parser" class="level2">
<h2 class="anchored" data-anchor-id="first-step-the-parser">First step: the parser</h2>
<p>Creating the parser went quite smoothly. I decided to create the <code>Reader</code> trait for reading individual characters from different sources (strings for unit tests, files, stdin) that would be used by the <code>read_sexpr</code> function for reading the <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Reader <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> peek(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> ReadError<span class="op">&gt;;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> ReadError<span class="op">&gt;;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To implement it, I used <a href="https://doc.rust-lang.org/book/ch06-02-match.html"><code>match</code></a> for pattern matching and it worked very nicely. It felt the same as good old pattern matching in functional programming languages.</p>
</section>
<section id="getting-stuck-for-the-first-time-linked-list" class="level2">
<h2 class="anchored" data-anchor-id="getting-stuck-for-the-first-time-linked-list">Getting stuck for the first time: linked list</h2>
<p>After being able to parse the atomic types, I was to add support for the lists. I tried and failed. I searched all the internet and saw the re-occurring advice: <em>“don’t”</em>. They gave many good arguments, but I <em>needed</em> the lists for my lisp. Then, I found a <a href="https://rust-unofficial.github.io/too-many-lists/index.html">book that focuses <em>only</em> on implementing linked lists in Rust</a> showing six (wat!?) different implementations. I borrowed from it the one from the <a href="https://rust-unofficial.github.io/too-many-lists/third-final.html">chapter four</a> because I needed an immutable list, that supports <code>head</code> (<code>car</code>) and <code>tail</code> (<code>cdr</code>) operations and makes them efficient. This finally worked.</p>
<p>Since Rust does not allow for sharing a value in different places, the linked list implementation used <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> a smart pointer that allows for read-only re-using of a variable by using a <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counter</a>. It serves as a very simple garbage collector.</p>
</section>
<section id="types" class="level2">
<h2 class="anchored" data-anchor-id="types">Types</h2>
<p>Working on the parser and defining the types for my lisp was a chance to learn about Rust’s type system. I was positively surprised by the <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html"><code>enum</code></a> type that fitted great for the purpose. It supports all the possible kinds of data as variants (no data, atomic types, structs, tuples, call it).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Sexpr <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    True<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    False<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    Symbol(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    Integer(<span class="dt">i64</span>)<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    Float(<span class="dt">f64</span>)<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">String</span>(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    Quote(<span class="dt">Box</span><span class="op">&lt;</span>Sexpr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    List(List<span class="op">&lt;</span>Sexpr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [...]</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The tricky part is that Rust needs to know about the size of the memory needed for the data at compilation time, so recursive types like <code>Quote</code> or <code>List</code> that can contain other <code>Sexpr</code>s need to be packed in a <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>, a smart pointer provided in the standard library to wrap around values for exactly such purposes. The memory footprint of <code>Box</code> is the size of the pointer.</p>
</section>
<section id="pleasant-surprise-the-traits-and-derive" class="level2">
<h2 class="anchored" data-anchor-id="pleasant-surprise-the-traits-and-derive">Pleasant surprise: the traits and <code>#[derive()]</code></h2>
<p>For my variables, I didn’t only want to store them. I needed to do things like copying, printing or comparing them. Did I need to implement all those things? No, Rust is smart enough to do it. I only added the <code>#[derive()]</code> statement to it. For example, to be able to compare if two lists are the same, I derived the <code>PartialEq</code> trait, to <a href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone">copy</a> the <code>Clone</code> trait and <code>Debug</code> trait for pretty printing when debugging and unit testing. If all the elements of the list follow those traits, and the list derives them, it is enough for it to work without any additional code.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Debug</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> List<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    head<span class="op">:</span> MaybePair<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are also traits that I implemented myself, like <code>Display</code> to print the values, <code>Iter</code> to iterate over the elements of the lists, <code>From&lt;T&gt;</code> to convert from the type <code>T</code> into the type that implements it, etc.</p>
<p>In fact, <code>#[derive()]</code> has saved my implementation. Initially, I implemented <code>List::clone</code> myself in a very inefficient way by doing a deep copy. It was completely unnecessary and when I noticed my mistake, I removed the implementation and replaced it with one line: <code>#[derive(Clone)]</code>. Without it, <code>clone</code> was working in <span class="math inline">\(O(n)\)</span> time, after it <span class="math inline">\(O(1)\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Before, the code was <em>extremely slow</em>, and after, very fast.</p>
</section>
<section id="second-step-the-environments" class="level2">
<h2 class="anchored" data-anchor-id="second-step-the-environments">Second step: the environments</h2>
<p>Environments are similar to linked lists in the sense that <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> are linked to the enclosing environments. When you call</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme code-with-copy"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((x <span class="dv">1</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   (<span class="op">+</span> x y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>it reads <code>x</code> from the local environment created by <code>let</code> and because <code>y</code> is not available there, it seeks for it in the environment enclosing the call, all the way down till it hits the root environment. The difference between lists and environments is that environments are tree-like structures (multiple environments can have the same parent), each environment is a mapping (here a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>), and we need read and write access to them.</p>
<p><code>Rc</code>, which I used in lists, does not allow for writing, so additionally I used <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> that permits mutable <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">borrowing</a> of the values. There are several other constructs like this (e.g.&nbsp;<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>), but I needed my interpreter to run single-threaded, so the simple <code>RefCell</code> sounded good enough and would likely be more efficient. The final implementation was defined in terms of a recursive data structure:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Env<span class="op">&lt;</span>T<span class="op">&gt;</span>(<span class="dt">Option</span><span class="op">&lt;</span>Rc<span class="op">&lt;</span>RefCell<span class="op">&lt;</span>EnvContainer<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;&gt;</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> EnvContainer<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    local<span class="op">:</span> HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> T<span class="op">&gt;,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    parent<span class="op">:</span> Env<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To avoid circular dependencies between the modules, I defined it as a generic <code>Env&lt;T&gt;</code>, using it in the code as <code>Env&lt;Sexpr&gt;</code>.</p>
<p>It is a nice example of how Rust encourages to use of its standard library which provides a lot of useful constructs that nicely work together. <code>Option&lt;Rc&lt;RefCell&lt;EnvContainer&lt;T&gt;&gt;&gt;&gt;</code> means that we use the <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> (yes, Rust ❤️ monads) for a nullable type (the root environment does not inherit from anything), <code>Rc</code> for re-using the contained values, <code>RefCell</code> for mutable borrowing, and on the bottom, the <code>EnvContainer&lt;T&gt;</code> that holds the <code>HashMap</code> with the local variable bindings and the link to the enclosing environment. Maybe it doesn’t look pretty, but all the constructs that made it work were provided to us in the standard library. So far, my impression of using Rust is that it’s mostly about being able to make use of the standard library. This is to a much larger degree than in the case of any other programming language I know.</p>
<p>The example also highlights the major difference between Go and Rust. Till recently, Go didn’t have generics and what it has now is rather limited. On another hand, Rust uses generics <em>a lot</em>. Even for a rather simple problem I was solving, generics a few times helped me to improve and declutter the code.</p>
</section>
<section id="third-step-the-evaluator" class="level2">
<h2 class="anchored" data-anchor-id="third-step-the-evaluator">Third step: the evaluator</h2>
<p>The evaluator didn’t seem hard to write. I started with something like below.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> sexpr <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Sexpr::</span>Symbol(name) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> env<span class="op">.</span>get(<span class="op">&amp;</span>name)<span class="op">.</span>ok_or(<span class="bu">Error</span><span class="pp">::</span>NotFound(name))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Sexpr::</span>Quote(<span class="kw">ref</span> quoted) <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Ok</span>(<span class="op">*</span>quoted<span class="op">.</span>clone())<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Sexpr::</span>List(<span class="kw">ref</span> list) <span class="op">=&gt;</span> <span class="cf">return</span> eval_list(list<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> env)<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Ok</span>(sexpr)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice a few things: I used here the <a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> monad (yes, again) for handling errors. It makes use of the operations provided in the standard library, including <code>.ok_or(err)</code> that translate the <code>Option::Some</code> result to <code>Resul::Ok</code> and <code>Option::None</code> to <code>Result::Err</code> for the given error message. That’s a nice use of monads. For <code>Quote</code> I needed to unbox the quoted value by dereferencing it with <code>*</code>. In some places, I needed to <code>.clone()</code> the values (recall, Rust does not allow us to re-use them).</p>
<p>It seemed to work, but only till I learned that Rust <a href="https://dev.to/seanchen1991/the-story-of-tail-call-optimizations-in-rust-35hf">is not tail-call optimized</a>. The recursion used everywhere in Scheme resulted in many stack overflow errors. I needed to implement the tail-call optimization for my interpreter. Hopefully, it’s less fancy than it sounds (check the <a href="https://github.com/twolodzko/rusch/blob/main/src/eval.rs">source code</a>, or <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step5">this link</a> if you’re curious).</p>
</section>
<section id="fourth-step-the-scheme-procedures" class="level2">
<h2 class="anchored" data-anchor-id="fourth-step-the-scheme-procedures">Fourth Step: the Scheme procedures</h2>
<p>For it to be a programming language, I needed not only the data types but also the (minimal) set of basic procedures. Here came a surprise. While the lisp data resides in linked lists, we would usually iterate through it by accessing the lists’ <code>head</code> and <code>tail</code> (recursively if needed). This is what most functional programming languages would do, but <a href="https://dev.to/seanchen1991/the-story-of-tail-call-optimizations-in-rust-35hf">not Rust</a>. The idiomatic way in Rust seems to be using the iterator. For it, we need to implement the <a href="https://doc.rust-lang.org/std/iter/"><code>Iter</code></a> trait, by providing the <code>.next()</code> method. It would give us for free many other methods like <code>map</code>, <code>filter</code>, <code>collect</code>, etc. However, it was not only about “nicer” code, but rather simplified it by enabling me to use many utilities from the standard library (told you so).</p>
<p>In Rusts iterator, <code>.next()</code> returns the <code>Option</code> monad: <code>Some(element)</code> result when the element exists and <code>None</code> if we already iterated through all the available elements. The pattern that I repeated many times when implementing Scheme procedures was <code>sexprs.iter().map(|elem| eval(elem, env))</code>, where <code>sexprs</code> is the list of S-expressions <code>List&lt;Sexpr&gt;</code>. In such a case <code>.next()</code> would return <code>Option&lt;Result&lt;Sexpr, Error&lt;Sexpr&gt;&gt;&gt;</code>, the <code>Option</code> nested in <code>Result</code>. Unpacking both was clumsy. Moreover, I wanted the iterator to stop on error. This lead me to come up with my iterator that stops on an error and saves the error message, otherwise returning the <code>Option&lt;Sexpr&gt;</code> results. When calling its <code>.next()</code> method, I call the <code>self.inter.next()</code> from the inner iterator and unpack it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">debug_assert!</span>(<span class="kw">self</span><span class="op">.</span>err<span class="op">.</span>is_none())<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>iter<span class="op">.</span>next()<span class="op">?</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(result) <span class="op">=&gt;</span> <span class="cn">Some</span>(result)<span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        err <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>err <span class="op">=</span> <span class="cn">Some</span>(err)<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Returning <code>None</code> marks that it was the final iteration. If you wonder what is the small <code>?</code> in the third line, it’s another cool feature of Rust. It’s a syntax that tells it to unpack the value contained in <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> or <a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> and propagate the <code>None</code> value or error, so you don’t need to write the boilerplate by yourself. How cool is that?</p>
<p>The above helped me to write procedures like <a href="https://www.scheme.com/tspl4/objects.html#./objects:s43"><code>list</code></a> with iterators, in just a few lines of code. The example below shows an iterator that goes through all the <code>args</code> evaluating them, then <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a>s the results to a lisp list <code>List&lt;Sexpr&gt;</code> (thanks to the fact that I already implemented the <code>FromIterator</code> trait for <code>List&lt;T&gt;</code>). In the end, I need to check if an error was raised by looking if <code>iter.err()</code> is not empty, then either raise it or return the result.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> list(args<span class="op">:</span> <span class="op">&amp;</span>Args<span class="op">,</span> env<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Env) <span class="op">-&gt;</span> FuncResult <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> iter <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> eval_iter(args<span class="op">,</span> env)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> list<span class="op">:</span> List<span class="op">&lt;</span>Sexpr<span class="op">&gt;</span> <span class="op">=</span> iter<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> iter<span class="op">.</span>err() <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(<span class="cn">Err</span>(msg)) <span class="op">=&gt;</span> <span class="cn">Err</span>(msg)<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="pp">Sexpr::</span>List(list))<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="getting-stuck-again-reading-lines-from-a-file" class="level2">
<h2 class="anchored" data-anchor-id="getting-stuck-again-reading-lines-from-a-file">Getting stuck again: reading lines from a file (?!)</h2>
<p>All the unit tests passed. It was finally time for an integration test. This meant that I needed not only to evaluate single-line code inputs but also whole files. The next step was to build a REPL. I assumed that doing both would be simple: I would read a line from a file, or standard input, and pass it to <code>StringReader</code> that I already had for reading from strings. The file could be processed line-by-line, for REPL I would be prompting the user for new lines. Easy peasy, I thought. But no, it wasn’t. If I read a line it is saved to a temporary variable, Rust does not allow preserving a state that would depend on such a temporary variable. I was struggling a bit, trying to add <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">lifetimes</a>, etc but with no luck. <a href="https://stackoverflow.com/questions/75138787/make-iterator-of-nested-iteratorsrus">The solution</a> was to clone all the characters from the string so the state can take ownership of them. Sounds easy when you know it. Now the reader when asked for a new character returns it from the cache, but when the cache is empty, it fills it with the new line.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> ReadError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>iter<span class="op">.</span>next() <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(<span class="pp">ReadError::</span>EndOfInput) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span><span class="op">.</span>iter <span class="op">=</span> <span class="pp">FileReader::</span>next_line(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>lines)<span class="op">?</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=&gt;</span> <span class="cf">return</span> result<span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>And <a href="https://github.com/twolodzko/rusch">here it is</a>! As with my <a href="implementing-lisps.html">other implementations</a>, I tested the code by running the examples from <em>The Little Schemer</em> book. I also ran benchmarks, and the Rust interpreter is faster than the one written in Go and slightly slower than the OCaml one (the fastest). Not bad.</p>
<p>It was a great learning opportunity. I started with book knowledge of Rust and ended up with hands-on experience with most of the core Rust concepts. It was hard. When writing a minimal lisp interpreter for the first time (in Go), the biggest problem was that I needed to learn a lot about the Scheme language and its internals. In Rust, I was struggling with the language. The learning curve <em>is</em> steep. Rust is built on many concepts that are not present elsewhere (e.g.&nbsp;<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">borrowing</a>). It is also deceitfully similar to many functional programming languages while being a much lower-level language. Programming in Rust is like using Haskell, with its types and strictness, but without recursion, and where you need to manage all the memory by yourself.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/haskell-cpp-rust.jpeg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Noah finds an animal on his Ark that is a penguin with an elephant’s head (described as Rust). He angrily asks a penguin (described as C++) and an elephant (described as Haskell) “What the hell is this?”.</figcaption><p></p>
</figure>
</div>
<p>Did I like it? Kind of. It has many great features. On another hand, to use it, you need to learn a lot about the language. With other programming languages, I use documentation to check some specific topics. In Rust, I had many tabs with the documentation for the standard library open constantly (<em>“was it <code>ok_or</code>, or maybe <code>ok_or_else</code>, or maybe <code>unwrap_or</code>..?”</em>). It’s also very verbose (I needed 1.4k lines of code vs 500 in OCaml or 600 in Lua).</p>
<p>On another hand, Rust’s compiler nitpicks a lot but also gives very informative messages and hints. Moreover, there is the <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> linter that told me exactly what and where should I change to make my code more idiomatic and how to simplify it. Rust is a (memory) safety freak, so it won’t let you create something that doesn’t work. You can do it correctly or never. I <em>can</em> understand why people like it. It constrains you a lot, but if you accept the constraints, Rust does many things to help you write better code.</p>
<p>It was fun!</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Clone all the elements in the list vs clone the reference in the head of the list.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>