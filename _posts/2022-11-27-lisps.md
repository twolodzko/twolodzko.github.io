---
layout: post
title:  "Lessons learned from implementing minimal Scheme four times"
permalink: /4-lisps
---

We were in the middle of a global pandemic. Tormented by fear, locked in our homes, everyone was coping differently. 
Some people started baking their own bread, writing poetry, learning to play guitar, or doing home gardening, and I...
started re-implementing Scheme lisps. Implementing minimal Scheme interpreters became my favorite programming Kata.
By "minimal" I mean bare-bones language but feature-rich enough that can run all the examples from the classic
*[The Little Schemer]* book by Daniel P. Friedman and Matthias Felleisen.

I did it four times already, in [Go], [OCaml], [Erlang], and [Racket] (itself a flavor of Scheme).
My main purpose was to learn new programming languages and learn more about programming language theory (in practice)
and their internals.
To verify my code, as an integration test I used the examples from *[The Little Schemer]* and accompanying unit tests
from the [repository by bmitc]. I am also benchmarking the code against MIT Scheme.

# Prologue

I don't have a computer science background, so one day I decided I want to learn more about programming language theory.
I started reading [the dragon book], though I never finished it. I needed something more practical and hands-on, and 
this is how I discovered the *[Build Your Own Lisp]* book. It was nice, but using code examples in C and focusing too
much on C for me. Hopefully, I also found the great *[Writing An Interpreter In Go]* book that used Go language to 
illustrate building an interpreter for a (non-lisp) programming language. Another great inspiration and source of help
was the [make a lisp repository] with an end-to-end tutorial and learning materials for freaks like me.
About the same time, I was reading the classic programming books: *[The Little Schemer]* and
*[Structure and Interpretation of Computer Programs]*, that used Scheme for the examples, so I was curious to write
my Scheme, to get better "behind the scenes" understanding. Among other resources, another helpful one was
*[The Scheme Programming Language]* book by R. Kent Dybvig.

# Go

I was curious about Go. The *[Writing An Interpreter In Go]* book motivated me, even more, to try implementing a lisp
in Go. I found Go very easy to learn, pleasant to work with, and having great documentation. To familiarize myself better
with the language, I've read the *[Learning Go]* book, that I can recommend. Implementing Scheme interpreter in Go
was not straightforward, because the two languages are *very* different. Listing all the differences would be pointless,
but the biggest one was that Go is statically typed, while Scheme is dynamically typed. Scheme has two basic data types:
atoms and lists of atoms. To implement dynamic typing in Go, one needs to use [`interface{}`] type and cast it to 
desired types each time it's needed. Scheme's lists are just [linked lists], that differ significantly from Go's native
arrays and [slices], so I decided to implement my own linked list defined as:

```go
type Pair struct {
    This Sexpr
    Next *Pair
}
```

I described the design of my implementation in greater detail in [the readme][Go] of my repository. It was a great
learning experience. I not only learned a lot about Scheme, but also the consequences of static vs dynamic typing,
passing by values vs references, linked lists, and many other things.

# OCaml

I knew basics of OCaml before deciding to write my second implementation of Scheme in it. The two books that were
a great introduction for me: *[OCaml from the Very Beginning]* and *[Real World OCaml]* (freely available online).
While working on it, I also found [this blog] where the author also implemented a lisp in OCaml.
Same as Scheme, OCaml uses lists as a basic data structure and recursion as the default working mode, which made
implementing it fairly straightforward. Moreover, OCaml has great pattern-matching utilities that made code much simpler
and more compact than the Go implementation (~500 lines vs ~2000 lines). OCaml's strong, but much more flexible than
Go's, typing was also of great help to prevent type inconsistencies and warn me about potential problems early on.
From the downsides, I didn't find OCaml documentation that fabulous and I struggled a bit to understand how should I
structure my project, handle dependencies, properly run unit tests, etc (it's not perfect). The biggest surprise was
that my implementation in OCaml was approximately five times faster than the one in Go "the fast language"! 

# Erlang

OK, that was a crazy one. I heard about Erlang and how it is an outlier in programming languages and wanted to learn
it for some time. Implementing Scheme in it seemed to be right in the sweet spot: not trivial, complex enough, but
doable in a finite amount of time, but also potentially touching on many features of the language. I wasn't aiming for
performance (Erlang is slow), or doing it most efficiently, but rather playing around with Erlang features.
Since Erlang was a bit scary to start with, I first read about Elixir (a language like Erlang, but with modern, Ruby-like
syntax) from the *[Programming Elixir]* book and did the [LeetCode learning track] (a good one). But I didn't want to
use Elixir but wanted to go hardcore (also "schemero" seemed to be a great name, tbh). I started by reading Erlang's 
author book *[Programming Erlang]*, but also found *[Learn You Some Erlang for Great Good!]* (available freely online)
very helpful. As Scheme and OCaml, Erlang mostly works with lists and recursion. Same as OCaml, it has great
pattern-matching utilities. But it has its quirks: its dynamically typed and does not really support custom types
(you can imitate them by using structs, e.g. `{symbol, "name"}` for a symbol type), moreover *every* object in Erlang
is immutable (what has many interesting consequences), it has a strange (but likable!) syntax and stylistic conventions.
The strangest of all is how Erlang treats everything as [message passing]. Since I wanted to learn more about it, my
parser is a server that communicates with another server that reads from a file or stdin and returns parsed objects 
when available (e.g. user types something in REPL). Also, I treated environments as servers, so that they can hold
all the Scheme objects and allow for mutating them (in Erlang you do mutability by playing [hot potato] and [passing the
state] between functions). The end product lacks a garbage collector, and is not efficient, but works and passes all
the tests. And, oh boy, what a ride it was.

# Racket

You may ask: *why would anyone implement Scheme in Scheme?!* In the end, the only thing you need to do is to run
something like `(eval (read ...))`. Yes, but that would be too easy. I wanted to have a parser that reads textual input
and parses it to Scheme-like objects, I wanted to imitate the types, environments, closures, etc. I found [Racket's 
documentation] very helpful (though not perfect). Having already read a lot about Scheme and implemented it thrice, 
doing it in Racket was fairly easy. It was a chance to appreciate Scheme's more advanced features like macros and
classes (yes, it has classes, but check *[Structure and Interpretation of Computer Programs]*
to learn how they are just syntactic sugar) to imitate the stateful environments. The biggest pain was when I decided
to build REPL and needed to find out how should I properly read the input from stdin and stream it to the parser
([xkcd] was right, as always).


 [The Little Schemer]: https://www.goodreads.com/book/show/548914.The_Little_Schemer
 [Go]: https://github.com/twolodzko/gosch
 [OCaml]: https://github.com/twolodzko/loco
 [Erlang]: https://github.com/twolodzko/schemero
 [Racket]: https://github.com/twolodzko/schsch
 [repository by bmitc]: https://github.com/bmitc/the-little-schemer
 [the dragon book]: https://www.goodreads.com/book/show/703102.Compilers
 [Build Your Own Lisp]: https://www.goodreads.com/book/show/21857827-build-your-own-lisp
 [Writing An Interpreter In Go]: https://www.goodreads.com/book/show/32681092-writing-an-interpreter-in-go
 [Structure and Interpretation of Computer Programs]: https://www.goodreads.com/book/show/43713.Structure_and_Interpretation_of_Computer_Programs
 [The Scheme Programming Language]: https://www.scheme.com/tspl4/
 [Learning Go]: https://www.goodreads.com/book/show/55841848-learning-go
 [`interface{}`]: https://golangdocs.com/interfaces-in-golang
 [linked lists]: https://en.wikipedia.org/wiki/Linked_list
 [slices]: https://go.dev/blog/slices-intro
 [Real World OCaml]: https://dev.realworldocaml.org/
 [OCaml from the Very Beginning]: https://www.goodreads.com/book/show/18212242-ocaml-from-the-very-beginning
 [this blog]: https://bernsteinbear.com/blog/lisp/00_fundamentals/
 [Programming Elixir]: https://www.goodreads.com/book/show/17971957-programming-elixir
 [LeetCode learning track]: https://leetcode.com/elixir/
 [Programming Erlang]: https://www.goodreads.com/book/show/808814.Programming_Erlang
 [Learn You Some Erlang for Great Good!]: https://learnyousomeerlang.com/contents
 [message passing]: https://www.erlang.org/blog/message-passing/
 [hot potato]: https://en.wikipedia.org/wiki/Hot_potato
 [passing the state]: https://learnyousomeerlang.com/more-on-multiprocessing#state-your-state
 [make a lisp repository]: https://github.com/kanaka/mal
 [Racket's documentation]: https://docs.racket-lang.org/index.html
 [xkcd]: https://xkcd.com/1425/
